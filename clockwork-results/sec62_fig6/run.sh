#!/usr/bin/bash

################################################################################
# Regarding experiments in Section 6.2 Does Clockwork Scale Up? (bursty_experiment)
################################################################################

SSH_PORT=22

# Clockwork docker uses port 2200
# SSH_PORT=2200 

SCRIPTPATH="$( cd "$(dirname "$0")" ; pwd -P )" # Absolute path to this script 
EXP_DIR="${SCRIPTPATH}"                         # Experiment dir

exp_name="bursty_experiment"                           # Codename
timestamp=`date "+%Y-%m-%d-%H-%M-%S"`                  # Start timestamp
logdir="/local/clockwork/${exp_name}/log/${timestamp}" # Log dir

if [ $# -gt 0 ]; then logdir=${1}; fi # Log dir may be specified as an argument
mkdir -p ${logdir}                    # Create log dir locally

################################################################################

client="volta10"      # Client (need not have any GPUs)
controller="volta11"  # Controller (need not have any GPUs)
worker="volta12"      # Worker (need to have GPUs)

# Username and password-free ssh command prefix
username="arpanbg"
ssh_cmd_prefix="ssh -p ${SSH_PORT} -o StrictHostKeyChecking=no -l ${username}"

mklogdir="mkdir -p ${logdir}; " # Command to create log dir on each machine

# It's a bit tricky to pass environment variables through SSH
# For now, we pass CLOCKWORK_MODEL_DIR and CLOCKWORK_DISABLE_INPUTS variables
# AFAIK, other variables used during compilation need not be passed
# We will add env_vars to all ssh commands
env_vars="export CLOCKWORK_MODEL_DIR=${CLOCKWORK_MODEL_DIR}; "
env_vars+="export CLOCKWORK_LOG_DIR=${logdir}; "
env_vars+="export CLOCKWORK_DISABLE_INPUTS=${CLOCKWORK_DISABLE_INPUTS}; "

################################################################################

#-------------------------------------------------------------------------
# Clockwork controller process usage:
#   controller [TYPE] [WORKERS] [OPTIONS]
# Description:
#   Run the controller of the given TYPE. Connects to the specified workers.
#   All subsequent options are controller-specific and passed to that controller.
# In this experiment, we use the following controller TYPE:
#   INFER4 (Up-to-date scheduler with loads and infers)
# Options specific to controller INFER4:
#   generate_inputs (bool, default false)
#     Should inputs and outputs be generated if not present.
#     Set to true to test network capacity.
#   max_gpus (int, default 100)
#     Set to a lower number to limit the number of GPUs.
#   schedule_ahead (int, default 10000000)
#     How far ahead, in nanoseconds, should the scheduler schedule.
#     If generate_inputs is set to true, the default value for this is 15ms, otherwise 5ms.
#   default_slo (int, default 100000000)
#     The default SLO to use if client's don't specify slo_factor.
#     Default 100ms
#   max_exec (int, default 25000000)
#     Don't use batch sizes >1, whose exec time exceeds this number.
#     Default 25ms
#   max_batch (int, default 8)
#     Don't use batch sizes that exceed this number. Default 8.
#-------------------------------------------------------------------------

generate_inputs="0" # Doesn't matter, inputs generated by the client
max_gpus="1"        # 1 GPU per worker

################################################################################

SECONDS=0
timeout_duration="75m"
printf "\nStarting Exp. ${exp_name} for ${timeout_duration}\n"
printf "The experiment log directory is ${logdir}\n"

# Stop any leftover Clockwork worker processes on the worker
echo "Stop any leftover Clockwork worker process on host ${worker}"
remote_cmd="pkill -f ${CLOCKWORK_BUILD}/worker"
echo "Remote worker cmd: ${remote_cmd}"
$(${ssh_cmd_prefix} ${worker} "${remote_cmd}")
echo "Sleeping 2m"
sleep 2m

# Start the Clockwork worker process remotely on the worker host
# Keep track of the worker process PIDs
# Sleep for a while, since the controller expects the worker to be ready
printf "Start Clockwork worker remotely on host ${worker}\n"
logfile="${logdir}/file=worker-${worker}.log"
remote_cmd="${mklogdir} ${env_vars} nohup ${CLOCKWORK_BUILD}/worker"
remote_cmd+=" > ${logfile} 2>&1 < /dev/null  & echo \$!"
printf "Remote worker cmd: ${remote_cmd}\n"
WORKER_PID=$(${ssh_cmd_prefix} ${worker} "${remote_cmd}")
echo "Worker process's PID ${WORKER_PID}"
printf "Sleeping 5s\n"
sleep 5s

# Start the Clockwork controller process remotely on the specified host
# Keep track of the controller process PID
# Sleep for a while, so that the controller is ready to serve requests
printf "\nStart Clockwork controller remotely on host ${controller}\n"
logfile="${logdir}/file=controller.log"
remote_cmd="${mklogdir} ${env_vars} nohup ${CLOCKWORK_BUILD}/controller"
remote_cmd+=" INFER5 ${worker}:12345 ${generate_inputs} ${max_gpus}"
remote_cmd+=" > ${logfile} 2>&1 < /dev/null & echo \$!"
printf "Remote controller cmd: ${remote_cmd}\n"
CONTROLLER_PID=$(${ssh_cmd_prefix} ${controller} "${remote_cmd}")
printf "Controller process's PID ${CONTROLLER_PID}\n"
printf "Sleeping 5s\n"
sleep 5s

#-------------------------------------------------------------------------
# Clockwork client process usage:
#   client [address] [workload] [workload parameters (if required)]
# In this experiment, we use the following workload:
#   bursty_experiment
# The workload does not require any parameters
#-------------------------------------------------------------------------

# Start the Clockwork client process remotely on the specified host
# Keep track of the client process PID
printf "\nStarting Clockwork client remotely on host ${client}\n"
logfile="${logdir}/file=client.log"
remote_cmd="${mklogdir} ${env_vars} nohup ${CLOCKWORK_BUILD}/client"
remote_cmd+=" ${controller}:12346 ${exp_name}"
remote_cmd+=" > ${logfile} 2>&1 < /dev/null & echo \$!"
printf "Remote client cmd: ${remote_cmd}\n"
CLIENT_PID=$(${ssh_cmd_prefix} ${client} "${remote_cmd}")
echo "Client process's PID ${CLIENT_PID}"
echo "Sleeping ${timeout_duration}"
sleep ${timeout_duration}

# Stop the client process after the specified duration
echo ""
echo "Stop Clockwork client on host ${client}"
remote_cmd="kill -2 ${CLIENT_PID}"
$(${ssh_cmd_prefix} ${client} "${remote_cmd}")

# The controller request telemetry file is at ${logdir}/clockwork_request_log.tsv
# Copy it to localhost after the experiment
echo ""
echo "Copying controller's request telemetry file to ${logdir}"
telemetryfile_dest="${logdir}/file=controller_request.tsv"
telemetryfile_src="${logdir}/clockwork_request_log.tsv"
$(scp -P ${SSH_PORT} ${username}@${controller}:${telemetryfile_src} ${telemetryfile_dest})

# The controller action telemetry file is at ${logdir}/clockwork_action_log.tsv
# Copy it to localhost after the experiment
echo ""
echo "Copying controller's action telemetry file to ${logdir}"
telemetryfile_dest="${logdir}/file=controller_action.tsv"
telemetryfile_src="${logdir}/clockwork_action_log.tsv"
$(scp -P ${SSH_PORT} ${username}@${controller}:${telemetryfile_src} ${telemetryfile_dest})

# Stop the controller process
printf "\nStop Clockwork controller on host ${controller}\n"
remote_cmd="kill -2 ${CONTROLLER_PID}"
$(${ssh_cmd_prefix} ${controller} "${remote_cmd}")

# Stop the worker process
printf "\nStop Clockwork worker on hosts ${worker}\n"
remote_cmd="kill -9 ${WORKER_PID}"
$(${ssh_cmd_prefix} ${worker} "${remote_cmd}")

duration=$SECONDS
printf "Exiting\n"
printf "Roughly $(($duration / 60)) minutes and $(($duration % 60)) seconds elapsed.\n"

################################################################################
